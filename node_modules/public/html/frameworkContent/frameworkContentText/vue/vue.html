<div>
    <p class="contentTitle">vue内容</p>
    <ul>
        说明：
        <li>
            vue.js:是一套构建用户界面的 渐进式框架,Vue 的核心库只关注视图层(渲染页面),放弃IE8及以下版本
        </li>
        <li>
            引入方式：
            <xmp>
                外网方式<script src="https://unpkg.com/vue/dist/vue.js"></script>
                本地方式（需下载）<script src="./vue.js"></script>
            </xmp>
        </li>
        <li>
            利用nodeJS+npm+vue搭建vue开发环境
            <ol>
                <li>
                    <p>node.js环境（npm包管理器）</p>
                    <p>cnpm  npm的淘宝镜像  npm install -g cnpm --registry=http://registry.npm.taobao.org</p>
                    <p>vue-cli 脚手架构建工具   cnpm install -g vue-cli</p>
                    <div class="tips">这三个可以安装到全局环境中</div>
                </li>
                <li>
                    <p>用vue-cli构建项目。cmd切换到项目下 vue init webpack firstVue 。这个命令的意思是初始化一个模板项目，其中webpack是构建工具，也就是整个项目是基于webpack的。其中firstVue是整个项目文件夹的名称，这个文件夹会自动生成在你指定的目录中</p>
                </li>
                <li>
                    运行初始化命令的时候回让用户输入几个基本的选项，如项目名称，描述，作者等信息。
                </li>
                <li>
                    <p>完成之后就可以看见一个项目文件了</p>
                    <img src="../../../../images/vue.png" alt="" style="width:800px;"/>
                </li>
                <li>
                    这个项目现在还只是一个结构框架，整个项目需要的依赖资源都还没有安装，依赖的文件都定义在package.json中
                </li>

                <li>
                    首先cmd到项目文件夹（firstVue文件夹），然后运行命令 cnpm install。即可安装项目所依赖的全部文件，依赖文件放在node_modules中。
                    <p class="tips">如果无法执行npm install，并且抛错。先把node-modules文件夹以及文件夹下的所有文件删除，再执行npm install。</p>
                </li>
                <li>
                    安装完项目依赖后就可以运行了 npm run dev。至此项目的骨架就搭建好了，可以进行vue开发了
                </li>
                <li>
                    项目文件介绍：
                    <pre>
                        1、package.json里面存放的是我们项目所依赖的文件，当另一个小伙伴需要共同开发时，只需将该项目拉到他本地，然后他再该目录下执行npm install，就可以安装所有项目依赖文件
                        2、index.html这是入口文件。里面虽然没有引入src文件夹下的main.js，但是webpack帮我们处理了,已经引入了main.js
                        3、
                    </pre>
                </li>
            </ol>
        </li>
        <li>
            使用前观摩
            <xmp>
                a、最基本的数据绑定
                <div id="app">
                    {{ message }}	//绑定数据
                </div>
                var app = new Vue({
                    el: '#app', //拿到界面dom
                    data: {     //数据
                        message: 'Hello Vue!'
                    }
                })

                b、通过v-bind绑定（常用绑定html标签的属性）
                <div id="app-2">
                    <span v-bind:title="message">
                        Hover your mouse over me for a few seconds to see my dynamically bound title!
                    </span>
                </div>
                var app2 = new Vue({
                    el: '#app-2',
                    data: {
                        message: 'You loaded this page on ' + new Date()
                    }
                })

                c、条件指令：只需要修改app3.seen的值即可达到效果
                <div id="app-3">
                    <p v-if="seen">Now you see me</p>
                </div>
                var app3 = new Vue({
                    el: '#app-3',
                    data: {
                        seen: true
                    }
                })
                setTimeout(function(){
                    app3.seen = false
                },2000)

                d、渲染数组多条数据（减少html字符串的拼接）
                <div id="app-4">
                    <ol>
                        <li v-for="todo in todos">
                            {{ + todo.text + }}  //注意：双花括号中的 两个 + 号，在应用时不需要，此处只是为了在html上显示出来而添加。类似angularJS中的绑定
                        </li>
                    </ol>
                </div>
                var app4 = new Vue({
                    el: '#app-4',
                    data: {
                        todos: [
                            { text: 'Learn JavaScript' },
                            { text: 'Learn Vue' },
                            { text: 'Build something awesome' }
                        ]
                    }
                })

                e、绑定事件（v-on:click="reverseMessage" 等价于 @click="reverseMessage"）
                <div id="app-5">
                    <p>{{ message }}</p>
                    <button v-on:click="reverseMessage">Reverse Message</button>
                </div>
                var app5 = new Vue({
                    el: '#app-5',
                    data: {
                        message: 'Hello Vue.js!'
                    },
                    methods: {
                        reverseMessage: function () {
                            this.message = this.message.split('').reverse().join('')
                        }
                    }
                })

                f、数据监听（监听数据的变化,变化时执行后面对应的function）
                var app5 = new Vue({
                    el: '#app-5',
                    data: {
                        message: 'Hello Vue.js!'
                    },
                    watch:{
                        "a":function(val,oldval){
                            console.log(val + "/" + oldval);
                        }
                    }
                })
            </xmp>
        </li>

        <li>
            上面的例子中常用
            <pre>
                new Vue({
                    el:"#app",
                    data: {
                        message: 'Hello Vue.js!'
                    },
                    methods:{
                        dosomething:function(){
                            ......
                        }
                    }
                })
                该方法在做一写小的例子时，非常实用。但对于大型应用更加推荐使用.vue的单文件组件。详情查看官方的 <a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank">demo</a>
            </pre>
        </li>

        <li>
            使用.vue的例子时：定义一个tableList.vue
            <xmp>
                <template>
                    <div>
                        <div class="tips">
                            这是罗亮的一个模板渲染引擎
                        </div>
                    </div>
                </template>

                <style scoped>   //此处的scoped是确定作用域，该style样式只作用于该组件，不会对其他的组件产生影响
                    .tips{
                        color:red;
                    }
                </style>

                <script>
                    export default {
                        name:'tableList',
                        data () {
                            return{
                                listItem:[1,2,3,4,5]
                            }
                        },
                        methods(){

                        }
                    }
                </script>

                在其他组件中使用时：引用该组件 import tableList from '../components/tableList.vue';
                export default {
                    data () {
                        return {
                            ......
                        }
                    },
                    components:{ tableList },  //注册通过import引入的tableList组件
                    methods:{
                        ......
                    }
                }
                那么界面上就直接可以使用<table-list></table-list>标签了,被替换成为末模板组件tableList.vue中的内容
            </xmp>
        </li>

        <li>
            关于组件间的传递参数，父-子传参，子-父传参。路由传参
            <xmp>
                1、父-子传递参数 props
                在father.vue中导入子组件child.vue后
                <child :data="data"></child>  //其中引号中的 "data"，是定义在data中的return中的data数据，同样可以绑定多个参数
                在child.vue中 定义一个props:['data']   //注意props是以数组的方式传递的，且为字符串。如果有多个则：['data','data1','data2']
                child.vue中使用该data和数据一样使用

                2、子-父传递参数，通过事件的传播方式传递参数
                在child.vue中自定义一个事件 this.$emit('childToFather',msg);  //自定义一个childToFather的事件,msg是传递的参数。
                在father.vue中监听事件 <child v-on:childToFather="listenToChild"></child>
                在methods中，添加监听到childToFather 的事件执行函数listenToChild(data),该方法中有一个data返回参数，里面就存放着msg对应的参数

                3、在vue2中废除了vue1中的dispatch和broadcast事件传播方法。假设第一点提出的父--子传递参数，改为事件传播就无能为力了。解决办法请查看下文中的 “vue中的事件传播”
            </xmp>
        </li>

        <li>
            关于路由
            <xmp>
                路由跳转的常见方式：
                1、常见用 <router-link to="/form">Form</router-link> 绑定跳转 "/form" 是定义路由时的path。等同于指令中的 <a v-link="{ path: '/home'}">Home</a>
                2、还有一种为函数式跳转 this.$router.push("/form") 来修改 url，完成跳转。
                3、replace属性：页面切换时不会留下历史纪录 <router-link :to="/home" replace></router-link>
                4、tag属性：有tag属性的router-link会被渲染成相应的标签
                <router-link :to="/home" tag="li">Home</router-link>
                渲染结果：<li>Home</li>

                路由的嵌套：参考：http://blog.csdn.net/github_26672553/article/details/54861174
                在当前路由Login下，再定义子路由。
                path: '/Login',
                name: 'Login',
                component: Login,
                children:[
                    { path: '/Login/Hello', component: Hello},
                    { path: '/Login/Hello', component: Hello}
                ]

                路由链接的激活状态
                routes: [
                    {
                        path: '/', redirect: '/Login'   //初次加载的路径
                    },{
                        path: '/Login',
                        name: 'Login',
                        component: Login,
                        linkActiveClass:'headItemActive'  //注意，路由默认的激活class为：router-link-exact-active。此处我们单独再添加一个headItemActive的class
                    },{
                        path: '/Hello',
                        name: 'Hello',
                        component: Hello,
                        linkActiveClass:'headItemActive'
                    }
                ]
                界面使用时：
                <router-link to="/Login" active-class="headItemActive">登陆界面</router-link>
                <router-link to="/Hello" active-class="headItemActive">首页</router-link>
                渲染出来是这样的：
                <a data-v-6a80d930 href="#/Login" class="router-link-exact-active headItemActive">登陆界面</a>
                所以一般定义当前路由激活状态用router-link-exact-active写css样式就可以了，这里只是为了说明可以单独定义headItemActive。

                //监听路由切换beforeEach切换前执行，afterEach切换成功后执行（此方法可以监听路由跳转时的函数，例如loadingBar加载条等）
                const router = new Router({
                    mode: "history",
                    routes: [{
                        path: '/',
                        redirect: '/Home' //初次加载的路径
                    },{
                        ......
                    }]
                })
                router.beforeEach((to, from, next) => {
                    iView.LoadingBar.start();
                    ......
                });
                router.afterEach((to, from, next) => {
                    iView.LoadingBar.finish();
                    ......
                });
            </xmp>
        </li>
        <li>
            关于vue组件加载完成后，执行的function
            <pre>
                一般在写vue组件加载完成后执行的函数用:
                mounted:{
                    ......
                }
                但是为了保证起见，推荐使用
                mounted:{
                    this.$nextTick(function(){
                        ......
                    });
                }
            </pre>
        </li>
        <li>
            vue中定义全局变量。例如host主机域名
            <xmp>
                1、使用全局js方式。
                即定义一个global.js文件，里面写入 global.url = "http://......"。然后再main.js中 import global from './global.js';
                使用时，只需要加上globa.url即可使用该变量。
                2、使用vue的组件方式。
                定义一个global.vue的组件。里面写入
                <script>
                    var url = "http://shopkeeper.api.dev.smartevent.net.cn:5048";
                    export default{
                        url
                    }
                </script>
                然后在需要的组件中引入 import global form './global.vue'
                在该组件中使用时 global.url。（切记在需要的组件中必须引入才可以使用，否则无法使用）
            </xmp>
        </li>

        <li>
            vue中的ajax
            <xmp>
                1、vue-resource（推荐使用，随后补上详细说明）
                2、原生ajax或者jq的ajax
            </xmp>
        </li>

        <li>
            vue中v-for获取索引
            <xmp>
                v-for="(data,index) in hotalTop10ShowData"
                这样在后面用index即为该条信息的索引值
                {{......}}括号中间只能是表达式，不能是语句。也就是说if(){......}else{......}是不起作用的。
                非要用的话应该这样{{ index < 9 ? '0' + (index + 1) : index + 1 }} 三目运算
            </xmp>
        </li>

        <li>
            vue中点击获取当前对象。
            <xmp>
                例如tab标签点击时，获取到点击当前的tab
                isShowFilter:function(){   //获取到的是当前点击的dom对象
                    console.log(event.currentTarget);
                }
            </xmp>
        </li>

        <li>
            修改vue-router地址栏中的 “#”
            <pre>
                在vue-router中，地址栏一般是这样的：http://localhost:8080/#/Home/HomePage
                在创建路由时添加 mode:"history"，属性就可以取消“#”
            </pre>
        </li>

        <li>
            vue中获取select中option的值 参考：https://segmentfault.com/q/1010000009881679
            <xmp>
                注意是 数据-模型
                <select v-model="selected">
                    <option v-for="test in tests" :value="test">{{ test.text }}</option>
                </select>
                <span>{{ selected.text }}</span>

                data(){
                    return{
                        tests:[
                            { value: 1, text: 'some text' },
                            { value: 2, text: 'some other text' },
                            { value: 3, text: 'some more text' },
                            { value: 4, text: 'text' },
                        ],
                        selected:""
                    }
                }
            </xmp>
        </li>
        <li>
            vue中 input 表单的获取值的方法
            <xmp>
                1、type=radio时（保持isCompliance的值和value的值一致时，即可让它成选中状态）
                <input type="radio" name="ifSure" value="1" v-model="isCompliance">是
                <input type="radio" name="ifSure" value="0" v-model="isCompliance">否
                data(){
                    return{
                        isCompliance:""
                    }
                }

                2、type=checkbox时
                <input type="checkbox" v-bind:value="index" v-on:click="selectIndex(item.rowId)" v-model="selectArr"/>

                3、select中option获取值（保持payMode的值和option中的value值一致时，即可达到选中效果）
                <select v-if="payTypeData" name="" id="selectPayType" v-model="payMode">
                    <option value="">请选择支付模式</option>
                    <option v-for="item in payTypeData" v-bind:value="item.val">{{ item.txt }}</option>
                </select>
                data(){
                    return{
                        payMode:""
                    }
                }
            </xmp>
        </li>

        <li>
            vue中，关于循环列表，点击更多按钮出现 下拉框按钮组的解决办法
            <xmp>
                <span v-on:click="isItemShow(index)">    //index是定义的循环的索引
                    更多
                    <img src="../../static/images/doubleDown.png"/>
                </span>
                <div v-show="index == itemShow">
                    <p v-on:click="detail(item.name,item.rowId)">
                        <img src="../../static/images/detail.png"/>
                        详情
                    </p>
                    <p v-on:click="relationHotal(item.name,item.rowId,item.el,item.nl)">
                        <img src="../../static/images/fenfa.png"/>
                        关联餐厅
                    </p>
                </div>

                data(){
                    return{
                        preItemShow:-1,
                        itemShow:-1
                    }
                }
                methods:{
                    isItemShow:function(index){
                        if(this.preItemShow == index){   //preItemShow用于记住上一次点击的index，如果前后两次一样的话，证明点击为同一个。那么久初始化
                            this.itemShow = -1;
                            this.preItemShow = -1;
                        }else{
                            this.itemShow = index
                            this.preItemShow = index
                        }
                    },
                }
            </xmp>
        </li>

        <li>
            vuex：
            组件之间的作用域独立，而组件之间经常又需要传递数据。
            A为父组件，下面有子组件 B 和 C。A的数据可以通过 :totalNum="totalNum" 传递给 B 和 C，B和C通过props:['data'],获取数据，使用和data中的一致用this.data。A 可以通过v-on:event监听子组件的事件，获取到B和C返回的参数this.$emit('event',参数)，从而操作 B 和 C 的数据。<br>
            但当 B 需要操作 C 的数据就会比较麻烦，需要先传到 A，再通过A传到 C。如果项目比较小的话还好，越大的项目，涉及的组件通信就越多、越频繁，此时管理起来就会非常累，而且容易出错。 <br/>
            在vue2中去掉了 $dispatch 和 $broadcast，传递参数就只有props和事件两种了。这就是 Vuex 的意义所在。它可以将数据置于单独的一层，并提供给外部操作内部数据的方法。

            <xmp>
            1、在main.js中定义全局的store（大型的项目推荐 单独建立一个store.js存放状态管理）
            const store = new Vuex.Store({
                state: {
                    count: 1
                },
                mutations: {
                    increment (state) {   //将state传递进去，不然无法操作state
                        state.count++
                    }
                }
            })
            2、在全局vue中注入store
                new Vue({
                    el: '#app',
                    router,
                    store,      //const 定义的store一定要注入全局的Vue中，这样每个单独的子组件才能获取到store
                    template: '<App/>',
                    components: { App }
                })
            3、在子组件中访问该状态
                computed:{
                    count () {
                        return this.$store.state.count
                    }
                },
                created:function(){
                    console.log(this.$store.state.count);
                },
            4、修改全局store下state中count的值。既然可以用this.$store.state.count访问，那也可以用该方法修改？？？
                这是一种错误的方法。修改只能通过定义在mutations对象中的方法，如上面的increment方法，那子页面如何调用该方法？
                在子组件中：
                created:function(){
                    console.log(this.$store.state.count);   //可以访问，但不能修改
                    this.$store.commit('increment');  //调用定义在mutations中的方法
                }
                //如果有参数
                mutations: {
                    increment (state, n) {
                        state.count += n
                    }
                }
                this.$store.commit('increment', 10)
            </xmp>
        </li>

        <li>
            vue中loading效果的制作。<br/>
            loading一般在发起http请求时出现，请求完成后结束。具体业务逻辑再进行修改<br/>
            loading放在vue的主页，如果是子界面的话，要调用loading就要用到vuex的全局state参数（详情参见vuex的使用方法），并修改该参数，完成loading的出现和隐藏
            <xmp>
                const store = new Vuex.Store({
                    state: {
                        isLoadingShow:false    //定义全局的是否显示loading的状态
                    },
                    mutations: {
                        changeLoadingShow (state) {     //定义修改loading为true的状态函数
                            state.isLoadingShow = true;
                        },
                        changeLoadingHide (state) {     //定义修改loading为false的状态函数
                            state.isLoadingShow = false;
                        }
                    }
                })
                那么在其他界面调用该方法，并修改参数
                getHotalList:function(){
                    var that = this;
                    var data = {
                        type:2
                    }
                    this.$store.commit('changeLoadingShow');  // loading加载效果图
                    axios.post(global.url + "/api/shop/PagingMealShop",data)
                    .then(function (response) {
                        that.$store.commit('changeLoadingHide');    // 取消loading加载图
                        if(response.status == 200){
                            that.pageData = response.data.rows;
                            that.totalNum = response.data.total;
                        }else{
                            alert("服务器端错误");
                        }
                    })
                    .catch(function (response) {
                        console.log(response);
                    });
                }
                注意：如果是一个界面在执行一个业务时，需要同时访问两个以上的http请求时，应该将这多个http请求一起发送，并监听他们是否同时返回
                // loading加载效果图
                this.$store.commit('changeLoadingShow');
                axios.all([axios.post(global.url + "/api/shop/QueryShopRank"), axios.post(global.url + "/api/shop/GetShopRecord"),axios.post(global.url + "/api/shop/GetDayPrePaymentRecord")])
                .then(axios.spread(function (first,second,third) {  //first,second,third对应数组中的http请求，返回的数据的顺序
                    // 取消loading加载图
                    that.$store.commit('changeLoadingHide');
                    that.hotalTop10ShowData = first.data;
                    that.hotalTop10Show = true;
                    that.hotalNum = second.data;
                    that.hotalNumShow = true;
                    that.totalMoney = third.data;
                    that.totalMoneyShow = true;
                }));
            </xmp>
        </li>

        <li>
            vue中的深拷贝。先来看看什么叫深拷贝？为什么要深拷贝。<a href="http://www.cnblogs.com/skura23/p/7072113.html" target="_blank">参考文档</a>
            <xmp>
                数组中时
                var a = [1,2,3];
                var b = a;
                b.push(4); // b中添加了一个4
                alert(a); // a变成了[1,2,3,4]

                对象中时
                var obj = {a:10};
                var obj2 = obj;
                obj2.a = 20; // obj2.a改变了，
                alert(obj.a); // 20，obj的a跟着改变
                这就是由于直接赋值，只是将引用指向同一个地址。而不是将地址中的内容copy。有些时候我们需要copy一份内容，虽然这会增大内存的使用。
            </xmp>
            解决办法：
            <xmp>
                // 先用JSON.stringify转换为JSON字符串，然后再用JSON.pares转换为JSON对象，能实现深拷贝
                computed: {
                    data: function () {
                        var obj={};
                        obj=JSON.parse(JSON.stringify(this.templateData)); //this.templateData是父组件传递的对象
                        return obj
                    }
                }
            </xmp>
        </li>
        <li>
            在使用iview框架时，自己书写的样式，无法覆盖掉iview的样式。<br/>
            解决办法在组件中的style样式中，将scoped取消掉
        </li>
        <li>
            vue中的事件传播。<a href="http://blog.csdn.net/a5534789/article/details/53415201" target="_blank">参考文档</a><br/>
            由于vue2.0 移除了1.0中的$dispatch 和$broadcast 这两个组件之间通信传递数据的方法 ,官方的给出的最简单的升级建议是使用集中的事件处理器,而且也明确说明了 一个空的vue实例就可以做到,因为Vue 实例实现了一个事件分发接口.
            <xmp>
                在入口main.js中添加数据模型
                new Vue({
                    el: '#app',
                    router,
                    render: h => h(App),
                    data: {    //添加的data数据模型
                        eventHub: new Vue()
                    }
                })

                组件中调用事件触发，通过this.$root.eventHub获取到此对象
                //调用$emit 方法
                this.$root.eventHub.$emit('YOUR_EVENT_NAME', yourData)

                另一个组件内调用事件接受
                this.$root.eventHub.$on('YOUR_EVENT_NAME',function(data){
                    console.log(data)   //通过事件传递过来的参数
                })
            </xmp>
        </li>

        <li>
            vuejs的指令部分。 <a href="http://blog.csdn.net/zuoziji416/article/details/53514412" target="_blank">参考文档</a>
            <xmp>
                1、vue自定义指令的基础用法
                //属性指令
                <div v-my-directive></div>
                Vue.directive('my-directive',function(el,binding,vnode,oldVnode){
                    console.log(el);    //el：指向调用的DOM元素：<div></div>，可以用来操作DOM
                    console.log(binding);  //binding：指的是引用指令my-directive中所传递的参数等信息
                    console.log(vnode);
                    console.log(oldVnode);
                })
                //元素指令
                <my-directive></my-directive>
                Vue.elementDirective('my-directive',function(el,binding,vnode,oldVnode){
                    console.log(el);    //el：指向调用的DOM元素：<div></div>，可以用来操作DOM
                    console.log(binding);  //binding：指的是引用指令my-directive中所传递的参数等信息
                    console.log(vnode);
                    console.log(oldVnode);
                })
                //详解
                el: 指令所绑定的元素，可以用来直接操作 DOM 。
                binding: 一个对象，包含以下属性：
                    name: 指令名，不包括 v- 前缀。
                    value: 指令的绑定值， 例如： v-my-directive="1 + 1", value 的值是 2。
                    oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
                    expression: 绑定值的字符串形式。 例如 v-my-directive="1 + 1" ， expression 的值是 "1 + 1"。
                    arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 "foo"。
                    modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。
                vnode: Vue 编译生成的虚拟节点，查阅 VNode API 了解更多详情。
                oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。

                2、vue自定义指令的分阶段用法
                Vue.directive('my-directive', {
                    bind: function(el,binding){   //只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作
                        //做绑定的准备工作
                        //比如添加事件监听器，或是其他只需要执行一次的复杂操作
                    },
                    inserted: function(){
                        //被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）
                    },
                    update: function(){
                        //根据获得的新值执行对应的更新
                        //对于初始值也会调用一次
                    },
                    componentUpdated: function(){
                        //被绑定元素所在模板完成一次更新周期时调用
                    },
                    unbind: function(){
                        //做清理操作
                        //比如移除bind时绑定的事件监听器
                    }
                })

                3、全局指令和局部指令
                全局指令：Vue.directive(......)指令的位置，应该放在new Vue(......)这个实例之前，切记否则会抛错！
                Vue.directive("modelDirectiv",function(el,binding){
                    ......
                })
                new Vue({
                    el: '#app',
                    router,
                    template: '<App/>',
                    components: { App },
                    data: {
                        eventHub: new Vue()
                    }
                })

                局部指令：
                new Vue({
                    ......
                　　directives:{
                　　　　dirName:{
                　　　　　　//定义指令
                　　　　}
                　　}
                });
            </xmp>
        </li>
    </ul>
</div>
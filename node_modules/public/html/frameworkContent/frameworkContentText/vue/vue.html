<div>
    <p class="contentTitle">vue内容</p>
    <ul>
        说明：
        <li>
            vue.js:是一套构建用户界面的 渐进式框架,Vue 的核心库只关注视图层(渲染页面),放弃IE8及以下版本
        </li>
        <li>
            引入方式：
            <xmp>
                外网方式<script src="https://unpkg.com/vue/dist/vue.js"></script>
                本地方式（需下载）<script src="./vue.js"></script>
            </xmp>
        </li>
        <li>
            利用nodeJS+npm+vue搭建vue开发环境
            <ol>
                <li>
                    <p>node.js环境（npm包管理器）</p>
                    <p>cnpm  npm的淘宝镜像  npm install -g cnpm --registry=http://registry.npm.taobao.org</p>
                    <p>vue-cli 脚手架构建工具   cnpm install -g vue-cli</p>
                    <div class="tips">这三个可以安装到全局环境中</div>
                </li>
                <li>
                    <p>用vue-cli构建项目。cmd切换到项目下 vue init webpack firstVue 。这个命令的意思是初始化一个模板项目，其中webpack是构建工具，也就是整个项目是基于webpack的。其中firstVue是整个项目文件夹的名称，这个文件夹会自动生成在你指定的目录中</p>
                </li>
                <li>
                    运行初始化命令的时候回让用户输入几个基本的选项，如项目名称，描述，作者等信息。
                </li>
                <li>
                    <p>完成之后就可以看见一个项目文件了</p>
                    <img src="../../../../images/vue.png" alt="" style="width:800px;"/>
                </li>
                <li>
                    这个项目现在还只是一个结构框架，整个项目需要的依赖资源都还没有安装，依赖的文件都定义在package.json中
                </li>

                <li>
                    首先cmd到项目文件夹（firstVue文件夹），然后运行命令 cnpm install。即可安装项目所依赖的全部文件，依赖文件放在node_modules中。
                </li>
                <li>
                    安装完项目依赖后就可以运行了 npm run dev。至此项目的骨架就搭建好了，可以进行vue开发了
                </li>
                <li>
                    项目文件介绍：
                    <pre>
                        1、package.json里面存放的是我们项目所依赖的文件，当另一个小伙伴需要共同开发时，只需将该项目拉到他本地，然后他再该目录下执行npm install，就可以安装所有项目依赖文件
                        2、index.html这是入口文件。里面虽然没有引入src文件夹下的main.js，但是webpack帮我们处理了,已经引入了main.js
                        3、
                    </pre>
                </li>
            </ol>
        </li>
        <li>
            使用前观摩
            <xmp>
                a、最基本的数据绑定
                <div id="app">
                    {{ message }}	//绑定数据
                </div>
                var app = new Vue({
                    el: '#app', //拿到界面dom
                    data: {     //数据
                        message: 'Hello Vue!'
                    }
                })

                b、通过v-bind绑定（常用绑定html标签的属性）
                <div id="app-2">
                    <span v-bind:title="message">
                        Hover your mouse over me for a few seconds to see my dynamically bound title!
                    </span>
                </div>
                var app2 = new Vue({
                    el: '#app-2',
                    data: {
                        message: 'You loaded this page on ' + new Date()
                    }
                })

                c、条件指令：只需要修改app3.seen的值即可达到效果
                <div id="app-3">
                    <p v-if="seen">Now you see me</p>
                </div>
                var app3 = new Vue({
                    el: '#app-3',
                    data: {
                        seen: true
                    }
                })
                setTimeout(function(){
                    app3.seen = false
                },2000)

                d、渲染数组多条数据（减少html字符串的拼接）
                <div id="app-4">
                    <ol>
                        <li v-for="todo in todos">
                            {{ + todo.text + }}  //注意：双花括号中的 两个 + 号，在应用时不需要，此处只是为了在html上显示出来而添加。类似angularJS中的绑定
                        </li>
                    </ol>
                </div>
                var app4 = new Vue({
                    el: '#app-4',
                    data: {
                        todos: [
                            { text: 'Learn JavaScript' },
                            { text: 'Learn Vue' },
                            { text: 'Build something awesome' }
                        ]
                    }
                })

                e、绑定事件（v-on:click="reverseMessage" 等价于 @click="reverseMessage"）
                <div id="app-5">
                    <p>{{ message }}</p>
                    <button v-on:click="reverseMessage">Reverse Message</button>
                </div>
                var app5 = new Vue({
                    el: '#app-5',
                    data: {
                        message: 'Hello Vue.js!'
                    },
                    methods: {
                        reverseMessage: function () {
                            this.message = this.message.split('').reverse().join('')
                        }
                    }
                })

                f、数据监听（监听数据的变化,变化时执行后面对应的function）
                var app5 = new Vue({
                    el: '#app-5',
                    data: {
                        message: 'Hello Vue.js!'
                    },
                    watch:{
                        "a":function(val,oldval){
                            console.log(val + "/" + oldval);
                        }
                    }
                })
            </xmp>
        </li>

        <li>
            上面的例子中常用
            <pre>
                new Vue({
                    el:"#app",
                    data: {
                        message: 'Hello Vue.js!'
                    },
                    methods:{
                        dosomething:function(){
                            ......
                        }
                    }
                })
                该方法在做一写小的例子时，非常实用。但对于大型应用更加推荐使用.vue的单文件组件。详情查看官方的 <a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank">demo</a>
            </pre>
        </li>

        <li>
            使用.vue的例子时：定义一个tableList.vue
            <xmp>
                <template>
                    <div>
                        <div class="tips">
                            这是罗亮的一个模板渲染引擎
                        </div>
                    </div>
                </template>

                <style scoped>   //此处的scoped是确定作用域，该style样式只作用于该组件，不会对其他的组件产生影响
                    .tips{
                        color:red;
                    }
                </style>

                <script>
                    export default {
                        name:'tableList',
                        data () {
                            return{
                                listItem:[1,2,3,4,5]
                            }
                        },
                        methods(){

                        }
                    }
                </script>

                在其他组件中使用时：引用该组件 import tableList from '../components/tableList.vue';
                export default {
                    data () {
                        return {
                            ......
                        }
                    },
                    components:{ tableList },  //注册通过import引入的tableList组件
                    methods:{
                        ......
                    }
                }
                那么界面上就直接可以使用<table-list></table-list>标签了,被替换成为末模板组件tableList.vue中的内容
            </xmp>
        </li>

        <li>
            关于组件间的传递参数，父-子传参，子-父传参。路由传参
            <xmp>
                1、父-子传递参数 props
                在father.vue中导入子组件child.vue后
                <child :data="data"></child>  //其中引号中的 "data"，是定义在data中的return中的data数据，同样可以绑定多个参数
                在child.vue中 定义一个props:['data']   //注意props是以数组的方式传递的，且为字符串。如果有多个则：['data','data1','data2']
                child.vue中使用该data和数据一样使用

                2、子-父传递参数，通过事件的传播方式传递参数
                在child.vue中自定义一个事件 this.$emit('childToFather',msg);  //自定义一个childToFather的事件,msg是传递的参数。
                在father.vue中监听事件 <child v-on:childToFather="listenToChild"></child>
                在methods中，添加监听到childToFather 的事件执行函数listenToChild
            </xmp>
        </li>

        <li>
            关于路由
            <xmp>
                路由跳转的常见方式：
                1、常见用 <router-link to="/form">Form</router-link> 绑定跳转 "/form" 是定义路由时的path
                2、还有一种为函数式跳转 this.$router.push("/form") 来修改 url，完成跳转。
                3、replace属性：页面切换时不会留下历史纪录 <router-link :to="/home" replace></router-link>
                4、tag属性：有tag属性的router-link会被渲染成相应的标签
                <router-link :to="/home" tag="li">Home</router-link>
                渲染结果：<li>Home</li>

                路由的嵌套：参考：http://blog.csdn.net/github_26672553/article/details/54861174
                在当前路由Login下，再定义子路由。
                path: '/Login',
                name: 'Login',
                component: Login,
                children:[
                    { path: '/Login/Hello', component: Hello},
                    { path: '/Login/Hello', component: Hello}
                ]

                路由链接的激活状态
                routes: [
                    {
                        path: '/', redirect: '/Login'   //初次加载的路径
                    },{
                        path: '/Login',
                        name: 'Login',
                        component: Login,
                        linkActiveClass:'headItemActive'  //注意，路由默认的激活class为：router-link-exact-active。此处我们单独再添加一个headItemActive的class
                    },{
                        path: '/Hello',
                        name: 'Hello',
                        component: Hello,
                        linkActiveClass:'headItemActive'
                    }
                ]
                界面使用时：
                <router-link to="/Login" active-class="headItemActive">登陆界面</router-link>
                <router-link to="/Hello" active-class="headItemActive">首页</router-link>
                渲染出来是这样的：
                <a data-v-6a80d930 href="#/Login" class="router-link-exact-active headItemActive">登陆界面</a>
                所以一般定义当前路由激活状态用router-link-exact-active写css样式就可以了，这里只是为了说明可以单独定义headItemActive。
            </xmp>
        </li>
        <li>
            关于vue组件加载完成后，执行的function
            <pre>
                一般在写vue组件加载完成后执行的函数用:
                mounted:{
                    ......
                }
                但是为了保证起见，推荐使用
                mounted:{
                    this.$nextTick(function(){
                        ......
                    });
                }
            </pre>
        </li>
        <li>
            vue中定义全局变量。例如host主机域名
            <xmp>
                1、使用全局js方式。
                即定义一个global.js文件，里面写入 global.url = "http://......"。然后再main.js中 import global from './global.js';
                使用时，只需要加上globa.url即可使用该变量。
                2、使用vue的组件方式。
                定义一个global.vue的组件。里面写入
                <script>
                    var url = "http://shopkeeper.api.dev.smartevent.net.cn:5048";
                    export default{
                        url
                    }
                </script>
                然后在需要的组件中引入 import global form './global.vue'
                在该组件中使用时 global.url。（切记在需要的组件中必须引入才可以使用，否则无法使用）
            </xmp>
        </li>

        <li>
            vue中的ajax
            <xmp>
                1、vue-resource（推荐使用，随后补上详细说明）
                2、原生ajax或者jq的ajax
            </xmp>
        </li>

        <li>
            vue中v-for获取索引
            <xmp>
                v-for="(data,index) in hotalTop10ShowData"
                这样在后面用index即为该条信息的索引值
                {{......}}括号中间只能是表达式，不能是语句。也就是说if(){......}else{......}是不起作用的。
                非要用的话应该这样{{ index < 9 ? '0' + (index + 1) : index + 1 }} 三目运算
            </xmp>
        </li>

        <li>
            vue中点击获取当前对象。
            <xmp>
                例如tab标签点击时，获取到点击当前的tab
                isShowFilter:function(){   //获取到的是当前点击的dom对象
                    console.log(event.currentTarget);
                }
            </xmp>
        </li>
    </ul>
</div>
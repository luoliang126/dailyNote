<div>
    <p class="contentTitle">闭包</p>
    <ol>
        <li>
            闭包：闭包就是能够读取其他函数内部变量的函数，由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。
            所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
        </li>

        <li>
            <p>闭包的作用</p>
            <ul>
                <li>
                    <p>可以读取函数内部的变量</p>
                    <pre>
                        function f1(){
                    　　　　var n=999;
                    　　　　function f2(){
                    　　　　　　alert(n);
                    　　　　}
                    　　　　return f2;
                    　　}
                    　　var result=f1(); //赋值方法,如果是var result = f1; 那么只是给它一个方法的引用，并未执行该方法，便不能形成闭包,在执行result()()时相当于重新执行了一次f1方法而已，那里面的变量n就会被重置;
                    　　result(); // 999
                    </pre>
                </li>
                <li>
                    <p>让变量的值始终保持在内存中。</p>
                    <pre>
                        function f1(){
                    　　　　var n=999;
                    　　　　nAdd=function(){n+=1}
                    　　　　function f2(){
                    　　　　　　alert(n);
                    　　　　}
                    　　　　return f2;
                    　　}
                    　　var result=f1(); //赋值方法,如果是var result = f1; 那么只是给它一个方法的引用，并未执行该方法,便不能形成闭包,在执行result()()时,相当于重新执行了一次f1方法而已，那么里面的变量n就会被重置;
                    　　result(); // 999
                    　　nAdd();
                    　　result(); // 1000
                        nAdd();
                    　　result(); // 1001
                    </pre>
                    <ol>
                        <li>
                            f1函数中的nAdd方法，因为没有用var nAdd，所以定义的nAdd为全局变量，而不是函数内的局部变量，虽然它存在函数内。可以在函数外部对函数内部的局部变量进行操作nAdd()直接使用。
                        </li>
                        <li>
                            在var result = f1();时，此时就已经执行了f1函数，从而f2方法暴露在了全局作用域下。注意重点来了，重要事情说三遍，f1中var n = 999,因为在函数f2中会使用到n所以在执行完函数f1后，n不会被垃圾回收，而是常驻内存，这也就是闭包的关键。
                        </li>
                        <li>
                            第一次执行result()时，就相当于f1()();那么执行的是return出来的f2函数，所以alert(n) //999
                        </li>
                        <li>
                            第一次nAdd()时，
                        </li>
                        <li>
                            第二次执行result()时，因为
                        </li>
                        <li class="tips">执行上下文、this等</li>
                    </ol>
                </li>
            </ul>
        </li>
        <li>
            <p>闭包的注意事项</p>
            <ul>
                <li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>
                <li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>
            </ul>
        </li>

        <li>
            <p>闭包实例</p>
            <pre>
　              var name = "The Window";
            　　var object = {
            　　　　name : "My Object",
            　　　　getNameFunc : function(){
            　　　　　　return function(){
            　　　　　　　　return this.name;
            　　　　　　};
            　　　　}
            　　};
            　　alert(object.getNameFunc()()); //The Window
            </pre>
            <pre>
                var name = "The Window";
            　　var object = {
            　　　　name : "My Object",
            　　　　getNameFunc : function(){
            　　　　　　var that = this;
            　　　　　　return function(){
            　　　　　　　　return that.name;
            　　　　　　};
            　　　　}
            　　};
            　　alert(object.getNameFunc()()); // My object
            </pre>
        </li>
    </ol>
</div>
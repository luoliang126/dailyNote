<div>
    <p class="contentTitle">js面向对象编程</p>
    <ol>
        <li>
            理解对象:对象的两种方式
            <ul>
                <li>
                    基于Object对象
                    <pre>
                        var person = new Object();
                        person.name = 'My Name';
                        person.age = 18;
                        person.getName = function(){
                            return this.name;
                        }
                    </pre>
                </li>
                <li>
                    对象字面量方式（比较清楚的查找对象包含的属性及方法）
                    <pre>
                        var person = {
                            name : 'My name',
                            age : 18,
                            getName : function(){
                                return this.name;
                            }
                        }
                    </pre>
                </li>
            </ul>
        </li>

        <li>
            对象的访问权限
            <pre>
                var person = {};
                Object.defineProperty(person, 'name', {
                    configurable: false, //表示能否使用delete操作符删除从而重新定义，或能否修改为访问器属性。默认为true;
                    Enumberable:true, //表示是否可通过for-in循环返回属性。默认true;
                    writable: false, //表示是否可修改属性的值。默认true;
                    value: 'Luoliang' //表示name的属性值
                });
                console.log(person.name);//Luoliang
                delete person.name; //不能删除掉
                console.log(person.name);//Luoliang
                person.name = 'bobo'; //也不能修改掉
                console.log(person.name);//Luoliang
            </pre>
        </li>

        <li>
            创建对象
            <ul>
                <li>
                    工厂模式：创建对象交给一个工厂方法来实现，可以传递参数，但主要缺点是无法识别对象类型，因为创建对象都是使用Object的原生构造函数来完成的，即person instanceof Object，而不是createPerson，因为它根本就不是一个构造函数
                    <pre>
                        function createPerson(name, age, job) {
                            var o = new Object();
                            o.name = name;
                            o.age = age;
                            o.job = job;
                            o.getName = function () {
                                return this.name;
                            }
                            return o;//使用return返回生成的对象实例
                        }
                        var person = createPerson('Jack', 19, 'SoftWare Engineer');
                    </pre>
                </li>
                <li>
                    构造函数模式：解决了构造函数指向问题，但在创建对象时，特别针对对象的属性指向函数时，会重复的创建函数实例。每次执行getName方法时都会创建函数实例。
                    <pre>
                        function Person(name,age,job){
                            this.name = name;
                            this.age = age;
                            this.job = job;
                            this.getName = function () {
                                return this.name;
                            }
                        }
                        var person1 = new Person('Jack', 19, 'SoftWare Engineer');
                        var person2 = new Person('Liye', 23, 'Mechanical Engineer');
                    </pre>
                </li>
                <li>
                    原型模式：解决了构造函数中每次执行getName方法时都会创建函数实例问题。但不能传递初始化参数，这在一定程序带来不便；另外，最主要是当对象的属性是引用类型时，它的值是不变的，总是引用同一个外部对象，所有实例对该对象的操作都会其它实例。
                    <pre>
                        function Person(){}
                        Person.prototype.name = 'Jack';//使用原型来添加属性
                        Person.prototype.age = 29;
                        Person.prototype.getName = function(){
                            return this.name;
                        }
                        var person1 = new Person();
                        alert(person1.getName());//Jack
                        var person2 = new Person();
                        alert(person1.getName === person2.getName);//true;共享一个原型对象的方法
                    </pre>
                </li>
                <li>
                    组合构造函数及原型模式:推荐使用方式，既能初始化传参，也不会在执行getName方法时多次创建函数实例化，不变的属性写在构造函数内，方法写在原型链上
                    <pre>
                        function Person(name, age, job) {
                            this.name = name;
                            this.age = age;
                            this.job = job;
                            this.lessons = ['Math', 'Physics'];
                        }
                        Person.prototype = {
                            constructor: Person,//原型字面量方式会将对象的constructor变为Object，这里强制指回Person
                            getName: function () {
                                return this.name;
                            }
                        }
                        var person1 = new Person('Jack', 19, 'SoftWare Engneer');
                        person1.lessons.push('Biology');
                        var person2 = new Person('Lily', 39, 'Mechanical Engneer');
                        alert(person1.lessons);//Math,Physics,Biology
                        alert(person2.lessons);//Math,Physics
                        alert(person1.getName === person2.getName);//true,//共享原型中定义方法
                        <div class="tips">
                            如果使用以下方式，那么person1的constructor还是指向Person，就没有必要再重新定义以下constructor的指向，但字面量方式简单直接方便查看;
                            Person.prototype.getName = function(){
                                return this.name;
                            }
                        </div>
                    </pre>
                </li>
            </ul>
        </li>

        <li>
            判断对象类型的几种方法
            <ul>
                <li>
                    constructor:每个实例化对象都有一个constructor指向构造他们的构造函数
                    <pre>
                        console.log(person1.constructor); //Person
                    </pre>
                </li>
                <li>
                    instanceof:判断某个对象是否属于另外一个对象，或被另外一个对象所创建。要求其左边的是一个对象，右边是对象类的名字或构造函数
                    <pre>
                        console.log(person1 instanceof Person); //true
                    </pre>
                </li>
                <li>
                    typeof:返回结果是一个数据类型的字符串。如："number"，"string"，"boolean"，"object"，"function"，"undefined"（可用于判断变量是否存在）。
                    <pre>
                        console.log(typeof person1); //object
                    </pre>
                </li>
                <li>
                    isPrototypeOf: 判断某个proptotype对象和某个实例之间的关系
                    <pre>
                        console.log(Person.prototype.isPrototypeOf(person1)); //true
                    </pre>
                </li>
                <li>
                    hasOwnProperty：用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。
                    <pre>
                        console.log(person1.hasOwnProperty("getName")); // false，因为getName属性是从原型prototype中继承过来的
                    </pre>
                </li>
                <li>
                    in：用来判断，某个实例是否含有某个属性（包括自身属性和prototype上的属性）
                    <pre>
                        console.log("name" in person1); // true,因为person1中有name属性
                    </pre>
                </li>
            </ul>
        </li>

        <li>
            继承：call/apply，以及函数的prototype
            <ul>
                <li>
                    call继承方法:将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行Animal.call(this,arguments);
                    <pre>
                        // 动物类
                        function Animal(arguments){
                            this.name = arguments[0];
                            this.age = arguments[1];
                            this.height = arguments[2];
                            this.color = arguments[3];
                            this.say = function(){
                                return "动物的名字叫：" + this.name + "。高度是：" + this.height + "。年龄是：" + this.age + "。颜色是：" + this.color
                            }
                        }
                        // 猫科类
                        function Cat(name,age,height,color){
                            //arguments是将所有的参数(name,age,height,color)组成一个数组传递过去，所有使用时用arguments[0],arguments[1],arguments[2],arguments[3]来赋值
                            Animal.call(this,arguments);
                        }
                        Cat.prototype.type = "猫科动物";
                        var cat1 = new Cat("大毛",27,168,"黑色");
                        console.log(cat1.type);
                    </pre>
                </li>
                <li>
                    apply继承方法:将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行Animal.apply(this,tips);
                    <pre>
                        // 动物类
                        function Animal(name,age,height,color){
                            this.name = name;
                            this.age = age;
                            this.height = height;
                            this.color = color;
                            this.say = function(){
                                return "动物的名字叫：" + name + "。高度是：" + height + "。年龄是：" + age + "。颜色是：" + color
                            }
                        }
                        //猫科类
                        function Cat(name,age,height,color){
                            //arguments是将所有参数组成一个对象传递过去，所以最后还是以name,age,height,color挨着赋值
                            var tips = [name,age,height,color]; //可以封装数组，也可以封装对象
                            Animal.apply(this,tips);
                    　　	}
                        Cat.prototype.type = "猫科动物";
                        var cat1 = new Cat("大毛",27,168,"黑色");
                        console.log(cat1.type);
                    </pre>
                </li>
                <li>
                    prototype继承方法
                    <pre>
                        function Animal(name,age,height,color){
                            this.name = name;
                            this.age = age;
                            this.height = height;
                            this.color = color;
                            this.say = function(){
                                return "动物的名字叫：" + name + "。高度是：" + height + "。年龄是：" + age + "。颜色是：" + color
                            }
                        }
                        function Cat(name,color){
                    　　　　	this.name = name;
                    　　　　	this.color = color;
                    　　	}
                        Cat.prototype = new Animal();
                        var cat1 = new Cat("大毛","黄色");
                        console.log(cat1.constructor); //指向Animal，而不是Cat
                        注：此时cat1虽然是由Cat构造器生成的，但Cat的prototype指向了Animal构造器的一个实例，所以Cat的prototype指向Animal，那生成的cat1也应该指向Animal。这显然会导致继承链的紊乱，所以需要手动加上Cat.prototype.constructor = Cat;

                        //当继承的属性在prototype上时，可以直接继承(不用通过new一个新的继承实例)eg：
                        function Animal(){}
                        Animal.prototype.type = "动物类"
                        function Cat(){}
                        Cat.prototype = Animal.prototype;
                        var cat1 = new Cat();
                        Cat.prototype.constructor = Cat;
                        console.log(cat1.type);
                    </pre>
                </li>
                <li>
                    利用空对象作为中介（推荐使用）
                    <pre>
                        function Animal(name,age,height,color){
                            this.name = name;
                            this.age = age;
                            this.height = height;
                            this.color = color;
                            this.say = function(){
                                return "动物的名字叫：" + name + "。高度是：" + height + "。年龄是：" + age + "。颜色是：" + color
                            }
                        }
                        function Cat(name,color){
                    　　　　	this.name = name;
                    　　　　	this.color = color;
                    　　	}
                        function extend(Child, Parent) {
                    　　　　	var F = function(){};	//空对象
                    　　　　	F.prototype = Parent.prototype;
                    　　　　	Child.prototype = new F();
                    　　　　	Child.prototype.constructor = Child;
                    　　　　	Child.uber = Parent.prototype;
                    　　	}
                        extend(Cat,Animal);
                    　　	var cat1 = new Cat("大毛","黄色");
                        console.log(cat1);
                    </pre>
                </li>
                <li>
                    拷贝继承：把父对象的所有属性和方法，拷贝进子对象。
                    <pre>
                        function Animal(){

                        }
                　　	Animal.prototype.style = "动物的公共属性";
                        Animal.prototype.method = "动物的公共方法";
                        Animal.prototype.do = function(){
                            console.log("动物都可以运动");
                        };
                        function Cat(){

                        }
                        function extend2(Child, Parent) {
                    　　　　	var p = Parent.prototype;
                    　　　　	var c = Child.prototype;
                            console.log(p);
                    　　　　	for (var i in p) {	//将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象
                    　　　　　　		c[i] = p[i];
                    　　　　	}
                    　　　　	c.uber = p;
                    　　	}
                        extend2(Cat, Animal);
                　　	var cat1 = new Cat("大毛","黄色");
                    </pre>
                </li>
                <li>
                    浅拷贝继承.
                    <pre>
                        var Chinese = {
                            nation:"Chinese",
                            face:"yellow",
                            birthPlace:["北京","上海","广州"]
                        }
                        function extendCopy(p) {
                    　　　　	var c = {};
                    　　　　	for (var i in p) {
                    　　　　　　		c[i] = p[i];
                    　　　　	}
                    　　　　	c.uber = p;//可不用
                    　　　　	return c;
                    　　	}
                        var Doctor = extendCopy(Chinese);
                    　　	Doctor.career = '医生';
                        Doctor.birthPlace.push("成都");
                        console.log(Doctor);
                        console.log(Chinese);
                        //注：浅拷贝的弊端，如Chinese中有一个birthPlace属性(数组),当我们在生成的Doctor往birthPlace中添加“成都”时，此时的Chinese中也添加了“成都”(因为我们拷贝的birthPlace只是数组的一个引用，而不是真正的拷贝，最终指向的还是该数组)，子属性修改影响到了父属性,解决方法：深拷贝
                    </pre>
                </li>
                <li>
                    深拷贝继承(当copy的chinese属性是一个对象或者数组时，再次循环该数组或对象，达到更深的拷贝)
                    <pre>
                        var Chinese = {
                            nation:"Chinese",
                            face:"yellow",
                            birthPlace:["北京","上海","广州"]
                        }
                        function deepCopy(p, c) {
                    　　　　	var c = c || {};
                    　　　　	for (var i in p) {
                    　　　　　　		if (typeof p[i] === 'object') {	//判断是否为数组或对象
                    　　　　　　　　		c[i] = (p[i].constructor === Array) ? [] : {};
                    　　　　　　　　		deepCopy(p[i], c[i]);
                    　　　　　　		} else {
                    　　　　　　　　		c[i] = p[i];
                    　　　　　　		}
                    　　　　	}
                    　　　　	return c;
                    　　	}
                        var Doctor = deepCopy(Chinese);
                        Doctor.career = '医生';
                        Doctor.birthPlace.push("成都");
                        console.log(Doctor);
                        console.log(Chinese);
                        //注：此时的Doctor中的birthPlace中有“成都”，但Chinese中没有“成都”，因为我们将birthPlace以及对应的["北京","上海","广州"]全部拷贝了(正因为如此，所以该方法很占内存)
                    </pre>
                </li>
            </ul>
        </li>
    </ol>
</div>
<div>
    <p class="contentTitle">js面向对象编程</p>
    <ol>
        <li>
            理解对象:对象的两种方式
            <ul>
                <li>
                    基于Object对象
                    <pre>
                        var person = new Object();
                        person.name = 'My Name';
                        person.age = 18;
                        person.getName = function(){
                            return this.name;
                        }
                    </pre>
                </li>
                <li>
                    对象字面量方式（比较清楚的查找对象包含的属性及方法）
                    <pre>
                        var person = {
                            name : 'My name',
                            age : 18,
                            getName : function(){
                                return this.name;
                            }
                        }
                    </pre>
                </li>
            </ul>
        </li>

        <li>
            对象的访问权限
            <pre>
                var person = {};
                Object.defineProperty(person, 'name', {
                    configurable: false, //表示能否使用delete操作符删除从而重新定义，或能否修改为访问器属性。默认为true;
                    Enumberable:true, //表示是否可通过for-in循环返回属性。默认true;
                    writable: false, //表示是否可修改属性的值。默认true;
                    value: 'Luoliang' //表示name的属性值
                });
                console.log(person.name);//Luoliang
                delete person.name; //不能删除掉
                console.log(person.name);//Luoliang
                person.name = 'bobo'; //也不能修改掉
                console.log(person.name);//Luoliang
            </pre>
        </li>

        <li>
            创建对象
            <ul>
                <li>
                    工厂模式：创建对象交给一个工厂方法来实现，可以传递参数，但主要缺点是无法识别对象类型，因为创建对象都是使用Object的原生构造函数来完成的，即person instanceof Object，而不是createPerson，因为它根本就不是一个构造函数
                    <pre>
                        function createPerson(name, age, job) {
                            var o = new Object();
                            o.name = name;
                            o.age = age;
                            o.job = job;
                            o.getName = function () {
                                return this.name;
                            }
                            return o;//使用return返回生成的对象实例
                        }
                        var person = createPerson('Jack', 19, 'SoftWare Engineer');
                    </pre>
                </li>
                <li>
                    构造函数模式：解决了构造函数指向问题，但在创建对象时，特别针对对象的属性指向函数时，会重复的创建函数实例。每次执行getName方法时都会创建函数实例。
                    <pre>
                        function Person(name,age,job){
                            this.name = name;
                            this.age = age;
                            this.job = job;
                            this.getName = function () {
                                return this.name;
                            }
                        }
                        var person1 = new Person('Jack', 19, 'SoftWare Engineer');
                        var person2 = new Person('Liye', 23, 'Mechanical Engineer');
                    </pre>
                </li>
                <li>
                    原型模式：解决了构造函数中每次执行getName方法时都会创建函数实例问题。但不能传递初始化参数，这在一定程序带来不便；另外，最主要是当对象的属性是引用类型时，它的值是不变的，总是引用同一个外部对象，所有实例对该对象的操作都会其它实例。
                    <pre>
                        function Person(){}
                        Person.prototype.name = 'Jack';//使用原型来添加属性
                        Person.prototype.age = 29;
                        Person.prototype.getName = function(){
                            return this.name;
                        }
                        var person1 = new Person();
                        alert(person1.getName());//Jack
                        var person2 = new Person();
                        alert(person1.getName === person2.getName);//true;共享一个原型对象的方法
                    </pre>
                </li>
                <li>
                    组合构造函数及原型模式:推荐使用方式，既能初始化传参，也不会在执行getName方法时多次创建函数实例化，不变的属性写在构造函数内，方法写在原型链上
                    <pre>
                        function Person(name, age, job) {
                            this.name = name;
                            this.age = age;
                            this.job = job;
                            this.lessons = ['Math', 'Physics'];
                        }
                        Person.prototype = {
                            constructor: Person,//原型字面量方式会将对象的constructor变为Object，这里强制指回Person
                            getName: function () {
                                return this.name;
                            }
                        }
                        var person1 = new Person('Jack', 19, 'SoftWare Engneer');
                        person1.lessons.push('Biology');
                        var person2 = new Person('Lily', 39, 'Mechanical Engneer');
                        alert(person1.lessons);//Math,Physics,Biology
                        alert(person2.lessons);//Math,Physics
                        alert(person1.getName === person2.getName);//true,//共享原型中定义方法
                        <div class="tips">
                            如果使用以下方式，那么person1的constructor还是指向Person，就没有必要再重新定义以下constructor的指向，但字面量方式简单直接方便查看;
                            Person.prototype.getName = function(){
                                return this.name;
                            }
                        </div>
                    </pre>
                </li>
            </ul>
        </li>

        <li>
            判断对象类型的几种方法
            <ul>
                <li>
                    constructor:每个实例化对象都有一个constructor指向构造他们的构造函数
                    <pre>
                        console.log(person1.constructor); //Person
                    </pre>
                </li>
                <li>
                    instanceof:判断某个对象是否属于另外一个对象，或被另外一个对象所创建。要求其左边的是一个对象，右边是对象类的名字或构造函数
                    <pre>
                        console.log(person1 instanceof Person); //true
                    </pre>
                </li>
                <li>
                    typeof:返回结果是一个数据类型的字符串。如："number"，"string"，"boolean"，"object"，"function"，"undefined"（可用于判断变量是否存在）。
                    <pre>
                        console.log(typeof person1); //object
                    </pre>
                </li>
                <li>
                    isPrototypeOf: 判断某个proptotype对象和某个实例之间的关系
                    <pre>
                        console.log(Person.prototype.isPrototypeOf(person1)); //true
                    </pre>
                </li>
                <li>
                    hasOwnProperty：用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。
                    <pre>
                        console.log(person1.hasOwnProperty("getName")); // false，因为getName属性是从原型prototype中继承过来的
                    </pre>
                </li>
                <li>
                    in：用来判断，某个实例是否含有某个属性（包括自身属性和prototype上的属性）
                    <pre>
                        console.log("name" in person1); // true,因为person1中有name属性
                    </pre>
                </li>
            </ul>
        </li>

        <li>
            继承、、、
        </li>
    </ol>
</div>
<div>
    ES6新特性。参考文献：<a href="http://es6.ruanyifeng.com/" target="_blank">ECMAScript 6 入门 --阮一峰著</a>
    <ol>
        <li>
            <span>let和const</span>
            <p>一般申明一个变量用var，这是一个全局的变量</p>
            <ul>
                <li>
                    let：使用let申明的变量只在let命令所在的代码块内有效，及块级作用域
                    <xmp>
                        {
                            let a = 10;
                            var b = 1;
                        }
                        a // ReferenceError: a is not defined.
                        b // 1
                    </xmp>
                    <p>常用于：for循环</p>
                </li>
                <li>
                    使用var存在”变量提升“现象，即没有定义过的变量，可以先使用。这不合理，而let没有！
                    <xmp>
                        使用var
                        console.log(foo); // 输出undefined
                        var foo = 2;

                        使用let
                        console.log(bar); // 报错ReferenceError
                        let bar = 2;
                    </xmp>
                </li>
                <li>
                    暂时性死区：只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）在这个区域，不再受外部的影响。
                    <xmp>
                        var tmp = 123;
                        if (true) {
                            tmp = 'abc'; // ReferenceError （此处抛错是因为，下一句let tmp，在该if作用域内定义前使用了变量tmp，即便有一个全局的tmp）
                            let tmp;
                        }
                    </xmp>
                </li>
                <li>
                    使用let时，在未定义变量前，使用变量都会抛错。而var不会。
                    <xmp>
                        if (true) {
                            console.log(tmp1);  //此处为undifined，而不是抛错
                            var tmp1 = 1;
                            tmp = 'abc'; // ReferenceError ，此处是抛错，而不是undifined
                            let tmp;
                        }
                    </xmp>
                </li>
                <li>
                    不允许重复申明，在同一块级作用域下，不允许使用let重复申明一个变量，跨作用域可以
                    <xmp>
                        错误方法
                        function test(){
                            let a = 1;
                            let a = 2; //抛错
                        }

                        正确方法
                        let a = 1;
                        function test(){
                            let a = 2;
                        }
                    </xmp>
                </li>
            </ul>
        </li>
        <li>
            <span>const的使用：申明一个只读的常量，一旦申明，常量的值就没法改变（只是引用地址不能改变，随后会详细解释）</span>
            <ul>
                <li>

                </li>
            </ul>
        </li>
    </ol>
</div>
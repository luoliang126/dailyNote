<div>
    ES6新特性。参考文献：<a href="http://es6.ruanyifeng.com/" target="_blank">ECMAScript 6 入门 --阮一峰著</a>
    <ol>
        <li>
            <span>let：一般申明一个变量用var，这是一个全局的变量，引入let后就存在块级作用域里，不会提升为全局</span>
            <ul>
                <li>
                    let：使用let申明的变量只在let命令所在的代码块内有效，及块级作用域
                    <xmp>
                        {
                            let a = 10;
                            var b = 1;
                        }
                        console.log(a) // ReferenceError: a is not defined.
                        console.log(b) // 1
                    </xmp>
                    <p>常用于：for循环</p>
                    <xmp>
                        for(let i=0;i<10;i++){
                            console.log(i);
                        }
                        console.log(i); //i is not defined
                    </xmp>
                </li>
                <li>
                    使用var存在”变量提升“现象，即没有定义过的变量，可以先使用。这不合理，而let没有！
                    <xmp>
                        使用var
                        console.log(foo); // 输出undefined
                        var foo = 2;

                        使用let
                        console.log(bar); // 报错ReferenceError
                        let bar = 2;
                    </xmp>
                </li>
                <li>
                    暂时性死区：只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）在这个区域，不再受外部的影响。
                    <xmp>
                        var tmp = 123;
                        if (true) {
                            tmp = 'abc'; // ReferenceError （此处抛错是因为，下一句let tmp，在该if作用域内定义前使用了变量tmp，即便有一个全局的tmp）
                            let tmp;
                        }
                    </xmp>
                </li>
                <li>
                    使用let时，在未定义变量前，使用变量都会抛错。而var不会。
                    <xmp>
                        if (true) {
                            console.log(tmp1);  //此处为undifined，而不是抛错
                            var tmp1 = 1;
                            tmp = 'abc'; // ReferenceError ，此处是抛错，而不是undifined
                            let tmp;
                        }
                    </xmp>
                </li>
                <li>
                    不允许重复申明，在同一块级作用域下，不允许使用let重复申明一个变量，跨作用域可以
                    <xmp>
                        错误方法
                        function test(){
                            let a = 1;
                            let a = 2; //抛错
                        }

                        正确方法
                        let a = 1;
                        function test(){
                            let a = 2;
                        }
                    </xmp>
                </li>
            </ul>
        </li>
        <li>
            <span>const的使用：申明一个只读的常量，一旦申明，常量的值就没法改变（只是引用地址不能改变，但可以往里面添加/删除数据，随后会详细解释）</span>
            <ul>
                <li>
                    常见案例
                    <xmp>
                        1、不能修改引用地址的情况
                        const a = 1;
                        a = 2;  //抛错 Assignment to constant variable.

                        2、修改引用地址中的值，但未修改引用地址时，正确
                        const a = [];
                        a.push(1);    //往数组中添加数据（可行），没有修改的值（引用地址未发生改变）
                        console.log(a); //a=[1]
                        a = [1];  //抛错，因为修改了引用地址
                    </xmp>
                </li>
                <li>
                    const的作用域和let的使用方法相同
                </li>
                <li>
                    <span class="tips">const的本质是：保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。</span>
                </li>
            </ul>
        </li>
        <li>
            变量的赋值
            <ul>
                <li>
                    let a = 1;
                    let b = 2;
                    let c = 3;
                    ES6语法
                    let [a,b,c] = [1,2,3];  //和上面得到的一样效果
                </li>
            </ul>
        </li>
        <li>
            函数的新方法
            <ul>
                <li>
                    ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。
                    <xmp>
                        function log(x, y = 'World') {
                            console.log(x, y);
                        }
                        log('Hello') // Hello World
                        log('Hello', 'China') // Hello China
                        log('Hello', '') // Hello
                    </xmp>
                </li>
                <li>
                    rest 参数（形式为...变量名）,用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
                    <xmp>
                        function add(...values) {
                            console.log(arguments); //arguments和values，都包含了参数数组[2,5,3]，不同的是values更加简洁
                            console.log(values);
                            let sum = 0;
                            for (var val of values) {
                                sum += val;
                            }
                            return sum;
                        }
                        add(2, 5, 3) // 10
                    </xmp>
                </li>
            </ul>
        </li>
    </ol>
</div>
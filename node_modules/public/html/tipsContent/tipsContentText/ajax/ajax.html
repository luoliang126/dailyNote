<div>
    <p class="contentTitle">
        ajax
    </p>
    <h4>
        方法一：原生封装ajax
    </h4>
    <pre>
    var request = new XMLHttpRequest();
    var method = "GET";
    request.open(method,url);
    request.send(null);
    request.onreadystatechange = function(){
        if(request.readyState == 4){
            if(request.status ==200 || request.status == 304){
                console.log(request.responseText);
            }
        }
    }
    </pre>
    <p>
        1、创建一个XMLHttpRequest对象
    </p>
    <pre>
        var request = new XMLHttpRequest();
    </pre>
    <p>
        2、配置url地址,配置method类型，以及传递参数
    </p>
    <pre>
        var method = "GET";
    </pre>
    <p>
        3、调用XMLHttpRequest对象的open()方法 打开
    </p>
    <pre>
        request.open(method,url);
    </pre>
    <p class="tips">
        批注：当我们请求的内容和上一次请求的内容一致时，服务器就会调用我们本地的缓存，而不是重新发送给客户端，但有时候我们
        即便是相同的，我们也需要服务器端重新发送的话，在url后面加上一个时间戳，这样请求的内容就永远不会一样了,禁用了缓存
        eg：var url= url + "?time=" + new Date();
    </p>
    <p>
        4、调用XMLHttpRequest对象的send()方法 发送
    </p>
    <pre>
        request.send(null);
    </pre>
    <p>
        5、XMLHttpRequest对象添加onreadystatechange事件 响应事件
    </p>
    <pre>
    request.onreadystatechange = function(){
        if(request.readyState == 4){
            if(request.status ==200 || request.status == 304){
                console.log(request.responseText);
            }
        }
    }
    </pre>

    <p>
        XMLHttpRequest的属性：
    </p>
    <p>
        1、onreadystatechange 每个状态改变都会触发这个时间处理器，通常会调用一个JavaScript函数
    </p>
    <p>
        2、readyState 请求的状态，有5个可用值，0代表未初始化，1代表正在加载，2代表已经加载，3代表交互中，4代表完成
    </p>
    <p>
        3、responseText 服务器的响应，表示一个串
    </p>
    <p>
        4、responseXML 服务器的响应，表示为XML，这个对象可以解析为DOM对象
    </p>
    <p>
        5、status 服务器的HTTP状态码（200对应OK,304对应上次请求后没有更新就可以不用上传节省流量开支，404对应not found服务器上没有找到对应的界面等，500服务器错误无法完成请求）
    </p>
    <p>
        6、statusText HTTP状态码的相应文本（ok,NOT found等）
    </p>
    <p>
        XMLHttpRequest的方法：
    </p>
    <p>
        1、abort() 停止当前请求
    </p>
    <p>
        2、getAllResponseHeaders() 把HTTP请求的所有响应首部作为键/值对返回
    </p>
    <p>
        3、getResponseHeader("header") 返回指定首部的串值
    </p>
    <p>
        4、open("method","url") 建立对服务器的调用，method:GET/POST/PUT,url:路径可以是相对路径也可以是绝对路径
    </p>
    <p>
        5、send(content) 向服务器发送请求附带参数，如果没有为null
    </p>
    <p>
        6、setRequestHeader("header","value") 把指定首部设置为所提供的值，在设置任何首部之前必须先调用open()
    </p>

    <h4>
        方法二：jquery中的ajax
    </h4>

    <h4>
        问题点：ajax跨域?
    </h4>
    <p>
        ajax跨域：我们经常会在页面上使用ajax请求访问其他服务器的数据,此时,客户端会出现跨域问题.
    </p>
    <p>
        服务器同一域名下：http://www.a.com/a.js 和 http://www.a.com/b.js 可以通讯
    </p>
    <p>
        服务器同一域名不同文件夹：http://www.a.com/lab/a.js 和 http://www.a.com/script/b.js	可以通讯
    </p>
    <p>
        服务器同一域名，不同端口：http://www.a.com:8000/a.js 和 http://www.a.com/b.js 不可以通讯
    </p>
    <p>
        同一域名，不同协议：http://www.a.com/a.js 和 https://www.a.com/b.js	不可以通讯
    </p>
    <p>
        域名和域名所对应的ip：http://www.a.com/a.js	和 http://70.32.92.74/b.js	不可以通讯
    </p>
    <p>
        主域相同，子域不同：http://www.a.com/a.js 和 http://script.a.com/b.js 不可以通讯
    </p>
    <p>
        不同域名：http://www.cnblogs.com/a.js 和 http://www.a.com/b.js 不可以通讯
    </p>
    <p>
        第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，
    </p>
    <p>
        第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。
        “URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。
    </p>
    <p>
        解决办法：详见http://blog.csdn.net/joyhen/article/details/21631833
    </p>
</div>